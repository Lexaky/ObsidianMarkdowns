**Created at** [29-11-2025 14:29]
**Tags**: #ML 
# Кластеризация

#### Рассматриваемое знание
Задача кластеризации - это обратная классификация. Есть точки, но у них нет классов, нужно к ним придумать классы.
Каким образом определять? - методом **k-means** (k-средних):
1) Среди точек, которые есть, объявляем k центров (центроиды).
2) Раскрасим каждую точку, согласно ближайшему ему центроиду.
12
3) Пересчитываем центроиды - нужно выбрать точку, у которой расстояние до всех остальных среднее, - как выбрать центр кластера? - с помощью алгоритма K-средних - взять среднее всех точек в каждом кластере (будет новая точка в каждом кластере, являющейся пересечением всех средних).
4) Повторить шаг 1, но теперь центроиды определены как средние.
Повторяем до тех пор, пока не будет превышено количество операций, либо пока не сойдёмся (пока точки не перестанут быть раскрашены одинаково на нескольких шагах), либо пока центроиды не будут меняться.
Изначально мы выбрали начальное состояние случайно - рандомно выбирали точки в качестве средних кластеров. Можно выбрать начальное состояние по-другому:
1 - Можно раскрасить точки случайно.
2 Можно ещё взять случайно кластеры, а потом начать пересчитывать центроиды и уточнять кластеры.
Все точки раскрашены случайно. Каждой выдаём класс с одинаковой вероятностью. Потом вычисляем центроиды.

3 - Инициализацией **k-means++**:
Первый центроид берётся случайно. Следующий центроид хотели бы выбрать так, чтобы он был как можно дальше от первого. Взвесить все точки, согласно расстоянию до 1 центроида. Чем точка дальше - тем больше вероятность, что она будет выбрана в качестве 2-го центроида. Далее выбираем случайно с весами, где вес - это минимальное расстояние ...
Без гарантий в среднем сходится быстрее алгоритма-предшественника.


Mixtures - представить точки в виде суммы распределений их весов
Обычно Gaussian Mixtures - предположим, что каждый из кластеров распределён согласно гауссовому распределению. Хотим согласно методу наибольшего правдоподобию ...
Как подбирать? - 
13
Их общее распределение - это ... 
$$\sum{p_if_{\mathcal{N}(\mu_i,\delta_i)}(x)}$$
Алгоритм похож на k-means, но сложнее и не сильно лучше.

Если количество кластеров не знаем, нужно пользоваться другими алгоритмами, основанными, например, на плотности.
Эти алгоритмы называются DBSCAN и OPTICS.
#### DBSCAN
15
Что делать в таком случае? 
В качестве параметров есть $\epsilon$ -..., и n - количество точек, необходимых для того, чтобы считать точку корневой. 
Точка является корневой, если в $\epsilon$-окрестности точки находится как минимум n точек. В более простой реализации сама себя точка тоже учитывает, поэтому получается n + 1 точек.
Обходим точки в каком-то порядке. Для каждой точки, если точка не помечена, как принадлежащая кластеру и является корневой, то инициализируем кластер. 
$if\ \nexists label(p) \&\ p\ -\ корневая\ (в\ окрестности\ как\ минимум\ n\ точек)$, то создаём кластер.
Когда точки закончились в $\epsilon$ окрестности, идём к следующей, ещё не затронутой кластерами.
Оставшиеся точки являются шумом, они выбрасываются.
Если $\epsilon$ будет малым - то получится много малых кластеров. Если выбрать большое значение, то может оказаться 1 кластер.
Плотностью является выражение $\frac{\epsilon}{n}$
Алгоритм зависит от порядка входа точек, но не очень сильно. Могут быть точки, которые находится на границе кластеров, и зависит от того, с какой стороны начать заражение кластерами
16
То-есть алгоритм детерминированный, но зависит от выбора первой точки, с которой начинается кластеризация.

#### OPTICS
Для каждой точки вычисляет некоторые значения
Начинаем с какой-то точки, вычисляем core_dist, он вычисляется только для корневых точек:
core_dist = undifned, if p не корневая
core_dist = min расстояние, чтобы набрать количество n (min $\epsilon$, содержащая n), else
reachability_dist считается для двух точек:
reachability_dist(p, q) = undefined, если q не корневая
reachability_dist(p, q) = min(core_dist(q), d(p, q)), else
Изначально все точки недостижимы. Проходим по всем точкам. Если core_dist существует, то начинаем помечать все точки вокруг неё как интересующие нас и вычислять reachability_dist.
17
Кластеры будут видны как скачки на графике.
Повышенный reachability_dist говорит о том, что точки находятся плотно
18


#### Вывод

#### Ссылки
Source Material and other similar notes