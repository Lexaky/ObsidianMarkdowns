**Created at** [22-11-2025 10:28]
**Tags**: #Database 
# Изоляция транзакций

#### Рассматриваемое знание
Транзакция - последовательности из одной или нескольких операций, которые должны быть выполнены как одна операция.
1
SELECT от какого-то запроса будет являться транзакцией или нет? Сам по себе SELECT может являться или не являться транзакцией при наборе определённых условий.
Мы считаем SELECT транзакцией, если она влияет на содержимое базы данных (например, в случае INSERT INTO (FROM SELECT...));
Если она находится внутри блока транзакций (до commit или revert'а);
Если она, например, делаем 2 select'а подряд, - в этом случае гарантируем ли мы себе, что результат будет одинаковый?
Даже если мы сделаем 2 одинаковых селекта, не факт что мы получим 2 одинаковых результата последовательно. У БД много клиентов и БД старается отвечать всем потребностям каждого клиента, результаты могут отличаться.
Транзакция - последовательность операций, которая начинается либо со специального оператора, либо после конца предыдущей транзакции, либо после прерывания предыдущей транзакции (есть операторы, которые так делают)
Транзакция не может быть встроенной или вложенной - полностью планарная структура. Есть идёт 2 оператора открытия транзакции, потом 2 оператора закрытия транзакции:
begin
begin
end
end
Будет на самом деле работать так: от begin до begin 1 транзакция, потом начало следующей транзакции автоматически прерывает предыдущую, поэтому будет 3 транзакции.
Мы надеемся, что БД настроены так, что паралелльные транзакции не оказывают друг на друга влияния (хотя это почти всегда не так, они оказывают почти всегда). 
В каком случае образуются параллельные транзакции, если 1 connection это 1 поток? Что нужно сделать, чтобы запустить паралелльную транзакцию? - у каждой СУБД есть лимит подключений, надо открыть новое подключение, чтобы выполнять паралелльно транзакции.

Как сделать так, чтобы транзакции друг на друга не влияли? - сделать их последовательными (последовательное выполнение) - и одновременно он самый медленный.
Синтаксис транзакции: для mysql, mariadb, oracle и т.д. есть специальные операторы, которые начинают транзакцию (start transaction) и её завершают. После старта идут надстройки, блок кода.
auto commit - коммит транзакции завершается после выполнения каждого действия. Каждая наша операция по умолчанию является транзакцией в таком случае.
Если стоит set auto commit, у кого-то ещё он стоит, ещё у третьего, то у нас начинается такая аномалия - перекрёстное смешивание транзакций. Мы думаем, что это 1 транзакция, а между ними легко вклиниваются транзакции конкурентов, из-за этого всё выполняется всё в произвольном порядке, отчего не работает правило Constistency.
С другой стороны, если ты аналитик данных, делаешь длинный запрос (просто селект), и обладаешь только правами для чтения, то без проблем можно поставить set auto commit и работать.
Если запросы длинные, выполняются долго, не влияют на базу, то можно ставить set auto commit.

commit - по умолчанию пытается изменения сохранить успешно
rollback - наоборот
В mysql по умолчанию commit по умолчанию включен.

6
Увидим результат, как только дойдём до секции commit'a

7
Настройка транзакции - есть set transaction, по умолчанию хар-ки:
isolation level - это базовая настройка, которую делает администратор. Их 4 от возможности допустить самую большую ошибку, до возможности допустить самую меньшую ошибку.
9
**Repeatable Read**. один из хороших уровней изоляции называется repeatable read - повторяющееся чтение, - говорит о том, что при двух операциях select мы гарантируем, что прочитаем одно и то же в этих двух select'ах. Какие сложности могут возникнуть? - появление фантомных чтений (mysql делает блокировки диапазонов строк в рамках одной таблицы). Фантомные чтения - мы можем прочитать неожиданно какие-то заблокированные строки. Это проявляется не в том, что если между селектами мы делаем действия, не затрагивающие одну и ту же таблицу, мы не гарантируем, что мы получим один и тот же результат двумя селектами.
Repeatable Read не даёт уверенности в двух непоследовательных чтениях.
Чтобы гарантировать, что такого не будет, существует только 1 уровень изоляции выше - **Serializable**.
Уровень Serialazible последовательно выполняет транзакции, не позволяет параллельного выполнения, медленный, но ошибок не случится.

read uncommited - изоляции нет совсем, читаем любые изменения, которые сделали другие транзакции, даже незавершённые. Он очень быстрый.
read commited - по умолчанию в postgres сделан. Он гарантирует, что мы в рамках транзакции будем видеть не все изменения всех транзакций, а только тех транзакций, которые уже закоммичены. Но он не гарантирует, что при последовательных селектах нет вероятности, что между ними встроится транзакция. Ни RC, ни RR не дают полной изоляции, ошибки могут быть и там, и там.
Serializable -> RR -> RC -> RU

Неповторяющееся чтение - это изменение кем-то во время нашего чтения - и это не самая плохая ошибка. 

В рамках одной транзакции у нас должно быть либо чтение, либо запись, но не должно быть ни чтения, ни записи одновременно. Иначе когда мы так делаем, возможно в процессе данные поменяются, проблема будет, когда мы запишем кусок старых данных с куском новых данных (нарушает Consistency)

access mode - read only или read write (эта транзакция настраиваемая будет либо только читать, либо только писать. Если она только читает, то её можно запускать в абсолютной параллели. Если она пишет, то её нельзя запускать параллельно ни с чем)

11
Настройка транзакции
Serializable - даже при нём возможны ошибки (ошибки многопоточного доступа к общим данным), такие ошибки возможны при любом многопоточном выполнении.

Вид ошибки (не при Serializable):
Deadlock - две транзакции. Если они запустятся одновременно, то они друг друга заблокируют, потому что они работают с одной и той же таблицей, с одинаковыми строками. Первая транзакция заблокирует stock_id=4 и дату такую-то, а вторая транзакция заблокирует stock_id=3 и другую дату, в итоге первая транзакция блокирует выполнение второй части второй транзакции, а вторая транзакция блокирует выполнение второй части первой транзакции.
Разблокируют все блоки только оператор commit.
В идеале такие транзакции запускать последовательно.
12
Явные блокировки. У баз данных есть разные движки. В mysql движок называется indb, в зависимости от движка работают по-разному уровни изоляции, блокировки.
Select for update позволяет в рамках одной транзакции произвести и чтение, и запись, блокируя все строчки, которые select прочитал, пока не произойдёт update. 
SELECT for UPDATE работает только с выключенным autocommit.

13
LOCK TABLES и UNLOCK TABLES
Блокируют таблицы таким образом, что все заблокированные таблицы до unlock tables или до завершения транзакций коммитом, эти таблицы будут заблокированы (другие таблицы с ними работать не смогут).
14
LT не является транзакционно-безопасным способом. Если мы устанавливаем блок по чтению, то этот поток и все остальные потоки могут из этой таблицы могут читать данные, но не могут туда писать.
15
Примеры
если мы уже начали блокировать таблицу, а потом обращаемся к другой, то мы должны делать либо unlock, либо лочить каждую таблицу, к которой обращаемся.
После введения синонима нужно работать с синонимом таблицы.
16
Исключения
Операторы DDL и операторы управления транзакциями прерывают транзакцию коммитом. (также как и операторные скобки, др.) - внутри транзакций таких операторов быть не должно.
Есть те, что по-умолчанию делают rollback. Это операторы, изменяющие индексы, изменяющие таблицы и др.



#### Вывод

#### Ссылки
Source Material and other similar notes