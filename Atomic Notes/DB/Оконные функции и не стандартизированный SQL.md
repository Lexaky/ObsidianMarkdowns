**Created at** [15-11-2025 10:09]
**Tags**: #Database
# Оконные функции и не стандартизированный SQL

#### Рассматриваемое знание
Ключевое `OVER()`

Почему оконная функция появилась в стандарте SQL поздно и почему нет ничего из реляционной алгебры, чтобы с ней правильно работать?
[3] Из-за порядка - в реляционной алгебре он отсутствует. (запись началась)

#### Для чего нужны оконные функции?
На большом объёме данных они работают быстрее, чем если бы запрос состоял из join'ов.
[4] 
[5]
`PARTITION BY` работает как `GROUP BY`

Это агрегатная функция, она выполняется в следующей последовательности:
OVER выполняется после JOIN, WHERE, GROUP BY (причём OVER будет работать над результатом GROUP BY, если он применялся), HAVING.
OVER выполняется до ORDER BY, LIMIT, DISTINCT.

#### Ограничения
Есть все агрегатные функции общего назначения (среднее, сумма, мин, макс, стандартное отклонение, подсчёт количества).
Есть специальные функции:
LAST_VALUE или FIRST_VALUE - выдаёт последнюю и первую строку из окна.
Если не будет значения начала окна, то что происходит?

#### Для создания
[10]
У окна есть 3 параметра:
[partition_clause] - 
[order_clause] - порядок сортировки в окне (до применения функции)
[frame_clause] - в чём считать unit'ы раздела. Есть frame units (могут быть строки и диапазоны) и fram extends (насколько эти строки распространяются)
Сортировка происходит до того, как будет вызвана функция, иначе бы это не имела смысла и выполнялось в произвольном порядке.
[11]
[12]
frame_units может быть либо rows, либо range. Если у нас определяется frame_extend - то от чего и до чего будет распространятся.
Что мб в виде frame_extend'а? [13]
current_row наше окно стартует с текущей строки.
Unbounded_preceding - без ограничений до начала ....
Unbounded following - "до конца"
over() - это от unbounded_preceding до unbounded_following

[14]
rows unbounded preciding - нумеруем строки с начала окна.

[15]
ROW_NUMBER() - она нумерует колонки.
row_number - показывает порядковый номер строки
rank - ранжирование с учётом дубликатов, у одинаковых значений будет одинаковые ранг.
dense_rank - нумерация без пропусков

- Любую функцию можно посчитать не используя оконные функции
(Количество строк и меньших + 1) - так можно посчитать rank.
Также можно в pratition by number можно посчитать rank.
[16]
Нам нужно посчитать аккумулятивную сумму (делаем SUM value over partition by subject ... от начала окна и до этого значения) и аккумулятивное среднее (поскольку оно будет не от начала окна, то мы составляем окно из нашей строчки, одной строки до и одной строчки после.)
Даже несмотря на то, что таблица продолжается, over не рассматривает following, где стоят нули в val и running_total.
[17]
[18]
`WITH RECURSIVE` имеет 2 части (вообще работает как цикл).
[19]
Рекурсивную таблицу нельзя создавать в подзапросе.
Хотим по сути пересортировать таблицу geo так, чтобы parent id следующей строки был ... (запись чекать)
Как написать правильно транзитивное замыкание? 
[20]
Использовать join, который присоединит текущую таблицу на данном шаге рекурсии.
При этом join будет join'ить и те строки, у которых не было рекурсивных строк.

#### Вывод

#### Ссылки
Source Material and other similar notes